from datetime import datetime, timedelta

from rest_framework.exceptions import ValidationError


def get_weekday_occurrences(from_date, to_date):
    """
    | Generates a length 7 array, where each index represents a weekday and contains an array with the dates that
      match the provided range.
    | This is an auxiliary method, and the "need" for this prebuilt structure stems from the fact that it is perhaps
      faster than iterating through every event while figuring the days it happens in provided a weekday
      and a range.
    :param from_date: Range start (inclusive)
    :param to_date: Range end (inclusive)
    :return: Weekday array
    """
    try:
        from_date = datetime.strptime(from_date, '%Y-%m-%d')
        to_date = datetime.strptime(to_date, '%Y-%m-%d')
    except ValueError:
        raise ValidationError(detail="Bad date range")
    if to_date < from_date:
        raise ValidationError(detail="Range goes back in time")

    delta: timedelta = to_date - from_date
    if delta.days > 31:
        raise ValidationError(detail="Range exceeds limit")

    weekday_occurrences = [[], [], [], [], [], [], []]
    day = from_date
    for _ in range(delta.days):
        weekday_occurrences[day.weekday()].append(day)
        day = day + timedelta(days=1)
    return weekday_occurrences


def append_turn_instances(destination, instances, weekday_occurrences):
    """
    Appends occurrences (in extension) of a set of turn instances in the provided days in the weekday bi-dimentional
    array (one result for each occurrence). Appends result to provided list.
    :param destination: List to which the results get appended
    :param instances: Collection of TurnInstance objects
    :param weekday_occurrences: Dict with list of days per weekday, as generated by get_weekday_occurrences.
    """
    for instance in instances:
        start_delta = timedelta(minutes=instance.start)
        duration_delta = timedelta(minutes=instance.duration)
        title = f'{instance.turn.class_instance.parent.abbreviation} {instance.turn.get_turn_type_display()}'

        for day in weekday_occurrences[instance.weekday]:
            start = day + start_delta
            end = start + duration_delta
            destination.append({
                'id': f"A{datetime.strftime(start, '%y%m%d')}{instance.id}",
                'type': instance.turn.type_abbreviation,
                'title': title,
                'start': start,
                'end': end
            })


def append_schedule_entries(destination, entries):
    """
    Appends schedule entries as a dict to the provided array.
    :param destination: List to which the results get appended
    :param entries: Collection of ScheduleOnce objects
    """
    for entry in entries:
        title = entry.title
        destination.append({
            'id': f"GO{entry.id}",
            'type': 'GO',
            'title': title,
            'start': entry.datetime.replace(tzinfo=None),
            'end': entry.datetime.replace(tzinfo=None) + timedelta(minutes=entry.duration)
        })


def append_periodic_schedule_entries_in_extension(destination, periodic_entries, weekday_occurrences):
    """
    Appends occurrences in extension of a set of periodic schedule entries in the provided days in the weekday
    bi-dimentional array (one result for each occurrence). Appends result to provided list.
    :param destination: List to which the results get appended
    :param periodic_entries: Collection of SchedulePeriodic objects
    :param weekday_occurrences: Dict with list of days per weekday, as generated by get_weekday_occurrences.
    """
    for entry in periodic_entries:
        duration_delta = timedelta(minutes=entry.duration)
        for day in weekday_occurrences[entry.weekday]:
            if not (entry.start_date <= day.date() <= entry.end_date):
                continue
            start_datetime = datetime.combine(day, entry.time)
            destination.append({
                'id': f"GP{datetime.strftime(day, '%y%m%d')}{entry.id}",
                'type': 'GP',
                'title': entry.title,
                'start': start_datetime,
                'end': start_datetime + duration_delta
            })
